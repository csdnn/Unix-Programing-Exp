                         实验1  同步与异步write的效率比较
                                 完成人：檀锦彬
                              完成时间：2016/10/08
一、实验内容
    本实验要求编写程序timewrite来比较同步与异步的写操作效率、以及不同缓冲区大小情况下的写操作效率，格式要求为：timewrite   <outfile>  [sync]，并严格按照教材p55表3-2的结果格式输出，BUFFSIZE从256至128K。

二、实验分析
    1、入口设计：利用I/O重定向指定输入文件，在程序中直接从STDIN_FILENO中读取；参数列表通过main函数的参数传递来判断是否指定O_SYNO常量
    2、时间获取：利用times函数，执行写操作前记录一次，写完毕再记录一次，相减后换算成秒数即为输出，其中包括了三种时间数据。
    3、排除read时间：设定一个同输入文件同长度的缓冲区，一次性读输入文件到缓冲区给write函数使用。获取文件长度可用lseek函数。
    4、为避免输出文件无限膨胀，在复制输入文件前应先将写位置复位到输出文件的开头（不能用O_APPEND打开输出文件），同时为了避免每次重新打开文件，可使用lseek来复位。

三、实验过程
    1、程序流程设计
      读取输入文件长度
      -> 设置缓冲区
      -> 记录时间
      -> 从缓冲区写入文件
      -> 记录时间
      -> 计算时间，换算
    2、细节实现
      (1)通过lseek( input,0,SEEK_END )获取文件长度input_length，设置缓冲区tmp_buf可以用malloc实现，应注意malloc的分配空间与lseek获得的长度单位不一致。
      (2)调用read将输入文件一次性存入tmp_buf，其返回值若和input_length不等，报错。
      (3)记录时间start
      (4)外循环使buffsize由256B递增至128KB,内循环将从tmp_buf内容分次写入outfile，每次写之前用lseek(outfile,0,SEEK_SET)重定位写位置，内循环结束后可能还需再读一次不足cur_buffsize的内容。
      (5)记录时间end
      (6)时间换算后，按要求输出。

四、实验结果
    1、源程序名：timewrite.c
    2、可执行程序名：timewrite
    3、执行gcc -o timewrite timewrite.c libapue.a生成可执行程序
    4、执行./timewrite <input output 打印异步写操作时不同缓冲区的效率比较
       执行./timewrite output sync <input 打印同步写操作时不同缓冲区的效率比较
    5、输出结果严格按照教材P55表3-2的格式输出

五、实验总结
    1、问题解决回顾
       (1)在read输入文件时，返回值为0。
       原因：计算文件长度时lseek将读位置定位到了文件尾导致read读取的内容为空。
       (2)malloc向系统申请分配size个字节的内存空间，lseek返回的长度也是字节为单位，因此不需要再用sizeof(char)*input_length来换算。
       (3)在写操作时进入死循环。
       原因：write从tmp_buf中读取内容时，不会自动移动读指针的位置，需要用一层循环控制。
    2、体会和建议
     通过自己编程比较同步与异步write的效率，对unix下的文件读写操作函数有了更熟练的掌握。通过观察实验结果，发现：
     (1)不同读写策略所耗费的时间有较大差距,缓冲区越大，写入效率越高，但随着缓冲区的增大，对写入效率的提高作用越小；
     (2)异步写比同步写效率要高，缓冲区越小，两者差距越大，随着缓冲区的增大，两者的差距逐渐减小。
     从实验结果中得到启发，在写入数据操作时要兼顾效率与同步性、安全性的均衡，选择合适的写入策略。
